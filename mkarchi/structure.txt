mkarchi/
â”œâ”€ __init__.py(begincontenu)
â”‚  """
â”‚  mkarchi - Create project structure from tree files
â”‚  """
â”‚  from .data import __version__, HELP_TEXT, is_empty_line, clean_line
â”‚  import os
â”‚  import re
â”‚  import sys
â”‚  
â”‚  
â”‚  def extract_content_from_line(line, base_indent):
â”‚      """
â”‚      Extract content from a line, removing tree characters and base indentation.
â”‚      
â”‚      Args:
â”‚          line: The line to process
â”‚          base_indent: The base indentation level to remove
â”‚          
â”‚      Returns:
â”‚          The extracted content, or None if line is empty/only tree chars
â”‚      """
â”‚      # Find where actual content starts (after tree chars and spaces)
â”‚      actual_start = 0
â”‚      for idx, char in enumerate(line):
â”‚          if char not in (' ', 'â”‚', 'â”œ', 'â””', 'â”€', '|'):
â”‚              actual_start = idx
â”‚              break
â”‚      else:
â”‚          # Line is only tree chars/spaces
â”‚          return None
â”‚      
â”‚      # Remove base indentation and return content
â”‚      if actual_start >= base_indent:
â”‚          return line[base_indent:].rstrip()
â”‚      else:
â”‚          # Line has less indentation than expected
â”‚          return line[actual_start:].rstrip()
â”‚  
â”‚  
â”‚  def parse_tree(file_path):
â”‚      """
â”‚      Parse a tree structure file and create directories and files.
â”‚      
â”‚      Args:
â”‚          file_path: Path to the structure file to parse
â”‚      """
â”‚      with open(file_path, "r", encoding="utf-8") as f:
â”‚          lines = f.readlines()
â”‚      
â”‚      stack = []
â”‚      current_file_content = []
â”‚      current_file_path = None
â”‚      collecting_content = False
â”‚      content_base_indent = None
â”‚      
â”‚      i = 0
â”‚      while i < len(lines):
â”‚          line = lines[i]
â”‚          
â”‚          # Check if we're collecting content
â”‚          if collecting_content:
â”‚              # Check for end marker
â”‚              if "(endcontenu)" in line:
â”‚                  # Save the content to file
â”‚                  if current_file_path:
â”‚                      with open(current_file_path, "w", encoding="utf-8") as f:
â”‚                          if current_file_content:
â”‚                              f.write("\n".join(current_file_content))
â”‚                              f.write("\n")
â”‚                      print(f"ğŸ“„ Created file with content: {current_file_path}")
â”‚                      
â”‚                  collecting_content = False
â”‚                  current_file_content = []
â”‚                  current_file_path = None
â”‚                  content_base_indent = None
â”‚                  i += 1
â”‚                  continue
â”‚              else:
â”‚                  # This is a content line
â”‚                  if content_base_indent is None:
â”‚                      # First content line - determine base indent
â”‚                      for idx, char in enumerate(line):
â”‚                          if char not in (' ', 'â”‚', 'â”œ', 'â””', 'â”€', '|'):
â”‚                              content_base_indent = idx
â”‚                              break
â”‚                      
â”‚                      if content_base_indent is None:
â”‚                          # Empty line
â”‚                          i += 1
â”‚                          continue
â”‚                  
â”‚                  # Extract content
â”‚                  content = extract_content_from_line(line, content_base_indent)
â”‚                  if content is not None:
â”‚                      current_file_content.append(content)
â”‚                  elif content is None and line.strip():
â”‚                      # Line has some content but was all tree chars - might be blank line in content
â”‚                      current_file_content.append("")
â”‚                  
â”‚                  i += 1
â”‚                  continue
â”‚          
â”‚          # Not collecting content - parse structure
â”‚          
â”‚          # Skip empty lines or lines with only tree characters
â”‚          if not line.strip() or is_empty_line(line):
â”‚              i += 1
â”‚              continue
â”‚          
â”‚          cleaned = clean_line(line)
â”‚          
â”‚          if not cleaned:
â”‚              i += 1
â”‚              continue
â”‚          
â”‚          # Look for tree structure markers (â”œ or â””)
â”‚          tree_match = re.search(r'[â”œâ””]', line)
â”‚          
â”‚          if tree_match:
â”‚              indent = tree_match.start()
â”‚              
â”‚              # Count the number of â”‚ or | characters before â”œ or â”” to determine level
â”‚              level = 0
â”‚              for char in line[:indent]:
â”‚                  if char in ('â”‚', '|'):
â”‚                      level += 1
â”‚              
â”‚              # Extract the name after the tree characters
â”‚              name_match = re.search(r'[â”œâ””]\s*â”€+\s*(.+)', line)
â”‚              if name_match:
â”‚                  name = name_match.group(1).strip()
â”‚              else:
â”‚                  i += 1
â”‚                  continue
â”‚          else:
â”‚              # No tree characters, could be root level
â”‚              level = 0
â”‚              name = cleaned
â”‚          
â”‚          # Validate the name - it should have alphanumeric characters
â”‚          # Skip if it's just tree characters or symbols
â”‚          if not name or not re.search(r'[a-zA-Z0-9_\-.]', name):
â”‚              i += 1
â”‚              continue
â”‚          
â”‚          # Check if file has content block
â”‚          has_content = False
â”‚          if "(begincontenu)" in name:
â”‚              has_content = True
â”‚              name = name.split("(begincontenu)")[0].strip()
â”‚          
â”‚          # After splitting, check again if name is valid
â”‚          if not name or not re.search(r'[a-zA-Z0-9_\-.]', name):
â”‚              i += 1
â”‚              continue
â”‚          
â”‚          is_dir = name.endswith("/")
â”‚          name = name.rstrip("/")
â”‚          
â”‚          # Replace forward slashes with hyphens to avoid path issues
â”‚          name = name.replace(" / ", "-")
â”‚          
â”‚          stack = stack[:level + 1]
â”‚          stack.append(name)
â”‚          path = os.path.join(*stack)
â”‚          
â”‚          if is_dir:
â”‚              os.makedirs(path, exist_ok=True)
â”‚              print(f"ğŸ“ Created directory: {path}")
â”‚          else:
â”‚              dir_path = os.path.dirname(path)
â”‚              if dir_path:
â”‚                  os.makedirs(dir_path, exist_ok=True)
â”‚              
â”‚              if has_content:
â”‚                  # Start collecting content
â”‚                  collecting_content = True
â”‚                  current_file_path = path
â”‚                  current_file_content = []
â”‚                  content_base_indent = None
â”‚              else:
â”‚                  # Create empty file
â”‚                  with open(path, "w", encoding="utf-8"):
â”‚                      pass
â”‚                  print(f"ğŸ“„ Created file: {path}")
â”‚          
â”‚          i += 1
â”‚      
â”‚      # Handle case where file ends while still collecting content
â”‚      if collecting_content and current_file_path:
â”‚          with open(current_file_path, "w", encoding="utf-8") as f:
â”‚              if current_file_content:
â”‚                  f.write("\n".join(current_file_content))
â”‚                  f.write("\n")
â”‚          print(f"ğŸ“„ Created file with content: {current_file_path}")
â”‚  
â”‚  
â”‚  def apply_structure(structure_file):
â”‚      """
â”‚      Apply a structure file to create directories and files.
â”‚      
â”‚      Args:
â”‚          structure_file: Path to the structure file
â”‚          
â”‚      Raises:
â”‚          FileNotFoundError: If the structure file doesn't exist
â”‚      """
â”‚      if not os.path.exists(structure_file):
â”‚          raise FileNotFoundError(f"File not found: {structure_file}")
â”‚      
â”‚      print(f"ğŸš€ Creating structure from {structure_file}...\n")
â”‚      parse_tree(structure_file)
â”‚      print("\nâœ… Architecture created successfully!")
â”‚  
â”‚  
â”‚  def should_ignore(path, name):
â”‚      """
â”‚      Check if a file or directory should be ignored.
â”‚      
â”‚      Args:
â”‚          path: The full path to check
â”‚          name: The name of the file/directory
â”‚          
â”‚      Returns:
â”‚          True if should be ignored, False otherwise
â”‚      """
â”‚      ignore_patterns = [
â”‚          '__pycache__',
â”‚          '.git',
â”‚          '.gitignore',
â”‚          'node_modules',
â”‚          '.env',
â”‚          '.venv',
â”‚          'venv',
â”‚          '.pytest_cache',
â”‚          '.mypy_cache',
â”‚          '__pycache__',
â”‚          '*.pyc',
â”‚          '*.pyo',
â”‚          '*.egg-info',
â”‚          'dist',
â”‚          'build',
â”‚          '.DS_Store',
â”‚          'Thumbs.db',
â”‚      ]
â”‚      
â”‚      for pattern in ignore_patterns:
â”‚          if pattern.startswith('*.'):
â”‚              # Pattern match
â”‚              if name.endswith(pattern[1:]):
â”‚                  return True
â”‚          else:
â”‚              # Exact match
â”‚              if name == pattern:
â”‚                  return True
â”‚      
â”‚      return False
â”‚  
â”‚  
â”‚  def count_files(directory="."):
â”‚      """
â”‚      Count total number of files to process (for progress bar).
â”‚      
â”‚      Args:
â”‚          directory: Directory to count files in
â”‚          
â”‚      Returns:
â”‚          Total number of files
â”‚      """
â”‚      total = 0
â”‚      try:
â”‚          for root, dirs, files in os.walk(directory):
â”‚              # Filter ignored directories
â”‚              dirs[:] = [d for d in dirs if not should_ignore(os.path.join(root, d), d)]
â”‚              # Count non-ignored files
â”‚              for f in files:
â”‚                  if not should_ignore(os.path.join(root, f), f):
â”‚                      total += 1
â”‚      except PermissionError:
â”‚          pass
â”‚      return total
â”‚  
â”‚  
â”‚  def print_progress_bar(current, total, bar_length=40):
â”‚      """
â”‚      Print a progress bar.
â”‚      
â”‚      Args:
â”‚          current: Current progress value
â”‚          total: Total value
â”‚          bar_length: Length of the progress bar in characters
â”‚      """
â”‚      if total == 0:
â”‚          percent = 100
â”‚      else:
â”‚          percent = int((current / total) * 100)
â”‚      
â”‚      filled = int((bar_length * current) / total) if total > 0 else bar_length
â”‚      bar = '=' * filled + '-' * (bar_length - filled)
â”‚      
â”‚      # Use \r to overwrite the same line
â”‚      sys.stdout.write(f'\r[{bar}] {percent}% ({current}/{total} files)')
â”‚      sys.stdout.flush()
â”‚      
â”‚      # Print newline when complete
â”‚      if current >= total:
â”‚          print()
â”‚  
â”‚  
â”‚  def generate_tree(directory=".", prefix="", output_lines=None, is_last=True, base_dir=None, 
â”‚                   include_content=True, max_size_kb=10, progress_info=None):
â”‚      """
â”‚      Generate a tree structure of the directory in mkarchi format.
â”‚      
â”‚      Args:
â”‚          directory: Directory to scan
â”‚          prefix: Prefix for tree drawing
â”‚          output_lines: List to collect output lines
â”‚          is_last: Whether this is the last item in current level
â”‚          base_dir: Base directory for relative paths
â”‚          include_content: Whether to include file contents
â”‚          max_size_kb: Maximum file size in KB to include content
â”‚          progress_info: Dictionary with 'current' and 'total' for progress tracking
â”‚          
â”‚      Returns:
â”‚          List of output lines
â”‚      """
â”‚      if output_lines is None:
â”‚          output_lines = []
â”‚      
â”‚      if base_dir is None:
â”‚          base_dir = directory
â”‚          # Add root directory name
â”‚          root_name = os.path.basename(os.path.abspath(directory))
â”‚          if not root_name:
â”‚              root_name = "project"
â”‚          output_lines.append(f"{root_name}/")
â”‚      
â”‚      try:
â”‚          items = sorted(os.listdir(directory))
â”‚          # Filter out ignored items
â”‚          items = [item for item in items if not should_ignore(os.path.join(directory, item), item)]
â”‚      except PermissionError:
â”‚          return output_lines
â”‚      
â”‚      # Separate directories and files
â”‚      dirs = [item for item in items if os.path.isdir(os.path.join(directory, item))]
â”‚      files = [item for item in items if os.path.isfile(os.path.join(directory, item))]
â”‚      
â”‚      all_items = dirs + files
â”‚      
â”‚      for i, item in enumerate(all_items):
â”‚          is_last_item = (i == len(all_items) - 1)
â”‚          item_path = os.path.join(directory, item)
â”‚          
â”‚          # Determine the connector
â”‚          if is_last_item:
â”‚              connector = "â””â”€"
â”‚              new_prefix = prefix + "   "
â”‚          else:
â”‚              connector = "â”œâ”€"
â”‚              new_prefix = prefix + "â”‚  "
â”‚          
â”‚          if os.path.isdir(item_path):
â”‚              # Directory
â”‚              output_lines.append(f"{prefix}{connector} {item}/")
â”‚              generate_tree(item_path, new_prefix, output_lines, is_last_item, base_dir, 
â”‚                           include_content, max_size_kb, progress_info)
â”‚          else:
â”‚              # File - update progress
â”‚              if progress_info:
â”‚                  progress_info['current'] += 1
â”‚                  print_progress_bar(progress_info['current'], progress_info['total'])
â”‚              
â”‚              if include_content:
â”‚                  try:
â”‚                      # Get file size
â”‚                      file_size_kb = os.path.getsize(item_path) / 1024
â”‚                      
â”‚                      # Try to read file content
â”‚                      with open(item_path, 'r', encoding='utf-8') as f:
â”‚                          content = f.read()
â”‚                      
â”‚                      # Check if file is within size limit and has content
â”‚                      if file_size_kb <= max_size_kb and content.strip():
â”‚                          # File has content and is small enough
â”‚                          output_lines.append(f"{prefix}{connector} {item}(begincontenu)")
â”‚                          # Add content with proper indentation
â”‚                          for line in content.split('\n'):
â”‚                              if line or content:  # Include empty lines
â”‚                                  output_lines.append(f"{new_prefix}{line}")
â”‚                          output_lines.append(f"{new_prefix}(endcontenu)")
â”‚                      else:
â”‚                          # File too large or empty, skip content markers
â”‚                          output_lines.append(f"{prefix}{connector} {item}")
â”‚                  except (UnicodeDecodeError, PermissionError):
â”‚                      # Binary file or no permission, skip content
â”‚                      output_lines.append(f"{prefix}{connector} {item}")
â”‚              else:
â”‚                  output_lines.append(f"{prefix}{connector} {item}")
â”‚      
â”‚      return output_lines
â”‚  
â”‚  
â”‚  def give_structure(output_file="structure.txt", include_content=True, max_size_kb=10):
â”‚      """
â”‚      Generate a structure file from the current directory.
â”‚      
â”‚      Args:
â”‚          output_file: Output file name (default: structure.txt)
â”‚          include_content: Whether to include file contents
â”‚          max_size_kb: Maximum file size in KB to include content
â”‚      """
â”‚      print(f"ğŸ” Scanning current directory...\n")
â”‚      
â”‚      # Count total files for progress bar
â”‚      total_files = count_files(".")
â”‚      print(f"ğŸ“Š Found {total_files} files to process\n")
â”‚      
â”‚      # Progress tracking
â”‚      progress_info = {'current': 0, 'total': total_files}
â”‚      
â”‚      output_lines = generate_tree(".", include_content=include_content, 
â”‚                                   max_size_kb=max_size_kb, progress_info=progress_info)
â”‚      
â”‚      print()  # New line after progress bar
â”‚      
â”‚      with open(output_file, 'w', encoding='utf-8') as f:
â”‚          f.write('\n'.join(output_lines))
â”‚      
â”‚      print(f"\nâœ… Structure file created: {output_file}")
â”‚      print(f"ğŸ“Š Total items: {len(output_lines)} lines")
â”‚      if include_content:
â”‚          if max_size_kb == float('inf'):
â”‚              print(f"ğŸ“ Max file size: No limit (all files included)")
â”‚          else:
â”‚              print(f"ğŸ“ Max file size included: {max_size_kb} KB")
â”‚      print(f"\nğŸ’¡ You can now share this file or use 'mkarchi apply {output_file}' to recreate the structure.")
â”‚  
â”‚  
â”‚  __all__ = [
â”‚      '__version__',
â”‚      'HELP_TEXT',
â”‚      'apply_structure',
â”‚      'give_structure',
â”‚      'is_empty_line',
â”‚      'clean_line',
â”‚  ]
â”‚  (endcontenu)
â”œâ”€ __main__.py(begincontenu)
â”‚  """
â”‚  Entry point for running mkarchi as a module
â”‚  """
â”‚  from .cli import main
â”‚  
â”‚  if __name__ == "__main__":
â”‚      main()
â”‚  (endcontenu)
â”œâ”€ cli.py(begincontenu)
â”‚  """
â”‚  Command-line interface for mkarchi
â”‚  """
â”‚  import sys
â”‚  import os
â”‚  
â”‚  # Handle both direct execution and package import
â”‚  if __name__ == "__main__" and __package__ is None:
â”‚      # Direct execution: add parent directory to path
â”‚      sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
â”‚      from mkarchi import __version__, HELP_TEXT, apply_structure, give_structure
â”‚  else:
â”‚      # Package import
â”‚      from . import __version__, HELP_TEXT, apply_structure, give_structure
â”‚  
â”‚  
â”‚  def show_help():
â”‚      """Display help information."""
â”‚      print(HELP_TEXT)
â”‚  
â”‚  
â”‚  def show_version():
â”‚      """Display version number."""
â”‚      print(f"mkarchi version {__version__}")
â”‚  
â”‚  
â”‚  def main():
â”‚      """Main entry point for the CLI."""
â”‚      if len(sys.argv) < 2:
â”‚          print("Usage: mkarchi <command> [options]")
â”‚          print("Try 'mkarchi --help' for more information.")
â”‚          sys.exit(1)
â”‚      
â”‚      command = sys.argv[1]
â”‚      
â”‚      if command == "--help":
â”‚          show_help()
â”‚          sys.exit(0)
â”‚      
â”‚      if command == "--version" or command == "-v":
â”‚          show_version()
â”‚          sys.exit(0)
â”‚      
â”‚      if command == "apply":
â”‚          if len(sys.argv) != 3:
â”‚              print("Usage: mkarchi apply <structure_file>")
â”‚              sys.exit(1)
â”‚          
â”‚          structure_file = sys.argv[2]
â”‚          
â”‚          try:
â”‚              apply_structure(structure_file)
â”‚          except FileNotFoundError as e:
â”‚              print(f"âŒ {e}")
â”‚              sys.exit(1)
â”‚          except Exception as e:
â”‚              print(f"âŒ Error: {e}")
â”‚              sys.exit(1)
â”‚      
â”‚      elif command == "give":
â”‚          # Parse options
â”‚          include_content = True
â”‚          output_file = "structure.txt"
â”‚          max_size_kb = 10  # Default 10 KB
â”‚          
â”‚          # Check for flags
â”‚          args = sys.argv[2:]
â”‚          for i, arg in enumerate(args):
â”‚              if arg == "-c" or arg == "--no-content":
â”‚                  include_content = False
â”‚              elif arg == "--no-max":
â”‚                  max_size_kb = float('inf')  # No limit
â”‚              elif arg.startswith("-max="):
â”‚                  try:
â”‚                      max_size_kb = int(arg.split("=")[1])
â”‚                  except ValueError:
â”‚                      print(f"âŒ Invalid max size: {arg}")
â”‚                      print("Usage: -max=<size_in_kb> (e.g., -max=100)")
â”‚                      sys.exit(1)
â”‚              elif not arg.startswith("-"):
â”‚                  output_file = arg
â”‚          
â”‚          try:
â”‚              give_structure(output_file, include_content, max_size_kb)
â”‚          except Exception as e:
â”‚              print(f"âŒ Error: {e}")
â”‚              sys.exit(1)
â”‚      
â”‚      else:
â”‚          print(f"Unknown command: {command}")
â”‚          print("Try 'mkarchi --help' for more information.")
â”‚          sys.exit(1)
â”‚  
â”‚  
â”‚  if __name__ == "__main__":
â”‚      main()
â”‚  (endcontenu)
â””â”€ data.py(begincontenu)
   """
   Data constants for mkarchi
   """
   
   __version__ = "0.1.7"
   
   HELP_TEXT = """
   mkarchi - Create project structure from tree files
   
   Usage:
       mkarchi apply <structure_file>              Create directories and files from structure file
       mkarchi give [options] [output_file]        Generate structure file from current directory
       mkarchi --help                              Show this help message
       mkarchi --version                           Show version number
       mkarchi -v                                  Show version number
   
   Examples:
       mkarchi apply structure.txt                 # Create structure from file
       mkarchi give                                # Generate structure.txt with file contents (max 10 KB)
       mkarchi give -c                             # Generate structure.txt without file contents
       mkarchi give -max=100                       # Include files up to 100 KB
       mkarchi give -max=50 myproject.txt          # Generate myproject.txt with 50 KB max size
       mkarchi give -c myproject.txt               # Generate myproject.txt without contents
   
   Options for 'give' command:
       -c, --no-content                            Don't include file contents (structure only)
       -max=<size_in_kb>                           Maximum file size in KB to include content (default: 10)
   
   Structure file format:
       project/
       â”œâ”€â”€ src/
       â”‚   â”œâ”€â”€ main.py(begincontenu)
       â”‚   â”‚   print("Hello World")
       â”‚   â”‚   (endcontenu)
       â”‚   â””â”€â”€ utils.py
       â”œâ”€â”€ README.md(begincontenu)
       â”‚   # My Project
       â”‚   This is a sample project.
       â”‚   (endcontenu)
       â””â”€â”€ requirements.txt
   
   Note: 
       - Directories should end with '/'
       - Files without content should not have markers
       - Files with content should use '(begincontenu)' and '(endcontenu)' markers
       - Files larger than max size will be listed without content
       - Progress bar shows scanning progress during 'give' command
   """
   
   
   def is_empty_line(line):
       """Check if line contains only spaces and tree characters."""
       for char in line:
           if char not in (' ', '|', 'â”‚', 'â”œ', 'â””', 'â”€'):
               return False
       return True
   
   
   def clean_line(line):
       """Remove comments and strip whitespace from line."""
       if "#" in line:
           return line[:line.find("#")].strip()
       return line.strip()
   (endcontenu)